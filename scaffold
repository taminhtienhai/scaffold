#!/usr/bin/env bash
# This script was generated by bashly 1.2.13 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script
# :command.root_command
root_command() {
  # src/root_command.sh
  set -euo pipefail
  IFS=$'\n\t'

  # --- Script Configuration ---
  readonly SCRIPT_NAME="scaffold"
  readonly SCRIPT_VERSION="1.2.0"
  readonly TEMP_DIR=$(mktemp -d)

  # --- Global Variables ---
  DEBUG=${args[--debug]:-}
  VERBOSE=${args[--verbose]:-}
  FORCE=${args[--force]:-}
  TEMPLATE_PATH=${args[--path]:-}
  GIT_REPO=${args[--git]:-}
  GIT_SUB_DIR=${args[--gitsubdir]:-}
  GROUP_ID=${args[--group-id]:-}
  ARTIFACT_ID=${args[--artifact-id]:-}
  OUTPUT_DIR=${args[--out]:-.}
  DESCRIPTION="A default description for my awesome app."
  AUTHOR="Jane Doe"
  PRE_HOOK=""
  POST_HOOK=""

  # --- Cleanup ---
  cleanup() {
      local exit_code=$?
      debug "Cleaning up temporary directory: $TEMP_DIR"
      rm -rf "$TEMP_DIR"
      rm -f "$OUTPUT_DIR/scaffold.ini"
      exit $exit_code
  }
  trap cleanup EXIT
  trap 'error "Script interrupted by user"; exit 130' INT TERM

  # --- Main Logic ---
  main() {
      if [[ -n "${args[--deps]:-}" ]]; then
          print_dependencies
          exit 0
      fi

      validate_args

      if [[ "$DEBUG" -eq 1 ]]; then
          debug "Configuration:"
          debug "  Template Path: ${TEMPLATE_PATH:-(none)}"
          debug "  Git Repo: ${GIT_REPO:-(none)}"
          debug "  Group ID: ${GROUP_ID:-(not set)}"
          debug "  Artifact ID: ${ARTIFACT_ID:-(not set)}"
          debug "  Output Dir: $OUTPUT_DIR"
          debug "  Force: $FORCE"
      fi

      log "Starting $SCRIPT_NAME v$SCRIPT_VERSION"

      local source_template_dir="$TEMP_DIR/source"
      mkdir -p "$source_template_dir"

      check_dependencies "rsync"
      if [[ -n "$GIT_REPO" ]]; then
          check_dependencies "git"
          log "Cloning template from $GIT_REPO..."
          git clone --depth 1 "$GIT_REPO" "$source_template_dir" || { error "Failed to clone repository: $GIT_REPO"; exit 1; }

          if ! [[ -z "$GIT_SUB_DIR" ]]; then
              source_template_dir="$source_template_dir/$GIT_SUB_DIR"
          fi
      else
          log "Copying local template from $TEMPLATE_PATH..."
          rsync -a --exclude='.git' --exclude='.gradle' --exclude='.env' "$TEMPLATE_PATH/" "$source_template_dir/"
      fi

      parse_ini_file "$source_template_dir/scaffold.ini"

      prompt_for_input "Enter Group ID (e.g., com.example.app)" GROUP_ID
      prompt_for_input "Enter Artifact ID (e.g., my-app)" ARTIFACT_ID

      if [[ -z "$GROUP_ID" || -z "$ARTIFACT_ID" ]]; then
          error "GroupID and ArtifactID are required."
          exit 1
      fi

      log "Project Configuration:"
      log "  Group ID:    $GROUP_ID"
      log "  Artifact ID: $ARTIFACT_ID"

      execute_hook "$PRE_HOOK" "pre-scaffolding"

      rsync -a "$source_template_dir/" "$OUTPUT_DIR/"
      log "Processing template..."
      replace_placeholders_and_structure "$OUTPUT_DIR"

      execute_hook "$POST_HOOK" "post-scaffolding"

      log "âœ… Project '$ARTIFACT_ID' successfully generated in: $OUTPUT_DIR"
  }

  main
}

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
scaffold_usage() {
  if [[ -n $long_usage ]]; then
    printf "scaffold\n\n"
    printf "  A CLI tool that generates a new Java project from an existing template.\n  It checks for a 'srcaffold.ini' file and creates the standard Java\n  directory structure based on the groupId and artifactId.\n\n"
  else
    printf "scaffold - A CLI tool that generates a new Java project from an existing template.\n\n"
  fi

  printf "%s\n" "Usage:"
  printf "  scaffold [OPTIONS]\n"
  printf "  scaffold --help | -h\n"
  printf "  scaffold --version | -v\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--deps"
    printf "    Show the list of required CLI tool dependencies and exit\n"
    echo

    # :flag.usage
    printf "  %s\n" "--debug, -d"
    printf "    Enable debug mode\n"
    echo

    # :flag.usage
    printf "  %s\n" "--verbose, -V"
    printf "    Enable verbose output\n"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    Force operation without confirmation (e.g., overwrite)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--path, -p PATH"
    printf "    Path to the local directory to use as a template.\n"
    echo

    # :flag.usage
    printf "  %s\n" "--git, -g GIT_REPO"
    printf "    URL of the git repository to use as a template.\n"
    echo

    # :flag.usage
    printf "  %s\n" "--gitsubdir GIT_SUB_DIRECTORY"
    printf "    Git sub directory from the root\n"
    echo

    # :flag.usage
    printf "  %s\n" "--group-id GROUP_ID"
    printf "    Java project's groupId (e.g., com.example.app)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--artifact-id ARTIFACT_ID"
    printf "    Java project's artifactId (e.g., my-app)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--out, -o DIR"
    printf "    Output project directory (default: current directory)\n"
    printf "    %s\n" "Default: ."
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  scaffold --path ~/templates/java-template --out ./my-new-project\n"
    printf "  scaffold --git https://github.com/user/java-template.git --out\n  ./my-new-project\n"
    printf "  scaffold --git https://github.com/user/java-template.git --gitsubdir\n  templates/java --out ./my-new-project\n"
    printf "  scaffold --path ~/templates/java-template --group-id com.mycompany\n  --artifact-id my-app\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/ini.sh
ini_load() {
  unset ini
  declare -gA ini

  local ini_file="$1"

  local section=""
  local key=""
  local value=""
  local section_regex="^\[(.+)\]"
  local key_regex="^([^ =]+) *= *(.*) *$"
  local comment_regex="^[;#]"

  while IFS= read -r line; do
    if [[ $line =~ $comment_regex ]]; then
      continue
    elif [[ $line =~ $section_regex ]]; then
      section="${BASH_REMATCH[1]}."
    elif [[ $line =~ $key_regex ]]; then
      key="${BASH_REMATCH[1]}"
      value="${BASH_REMATCH[2]}"
      [[ $value == *\$* ]] && eval "value=\"$value\""
      ini["${section}${key}"]="$value"
    fi
  done <"$ini_file"
}

ini_save() {
  declare -gA ini

  local ini_file="$1"

  local current_section=""
  local has_free_keys=false

  rm -f "$ini_file"

  for key in $(ini_keys); do
    [[ $key == *.* ]] && continue
    has_free_keys=true
    value="${ini[$key]}"
    echo "$key = $value" >>"$ini_file"
  done

  [[ "${has_free_keys}" == "true" ]] && echo >>"$ini_file"

  for key in $(ini_keys); do
    [[ $key == *.* ]] || continue
    value="${ini[$key]}"
    IFS="." read -r section_name key_name <<<"$key"

    if [[ "$current_section" != "$section_name" ]]; then
      [[ $current_section ]] && echo >>"$ini_file"
      echo "[$section_name]" >>"$ini_file"
      current_section="$section_name"
    fi

    echo "$key_name = $value" >>"$ini_file"
  done
}

ini_show() {
  declare -gA ini

  for key in $(ini_keys); do
    echo "$key = ${ini[$key]}"
  done
}

ini_keys() {
  declare -gA ini

  local keys=("${!ini[@]}")
  for a in "${keys[@]}"; do echo "$a"; done | sort
}

# src/lib/logging.sh
# --- Colors for Output ---
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly PURPLE='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly NC='\033[0m' # No Color

# --- Logging Functions ---
log() {
    echo -e "${GREEN}[INFO]${NC} $*" >&2
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $*" >&2
}

error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

debug() {
    if [[ "$DEBUG" -eq 1 ]]; then
        echo -e "${PURPLE}[DEBUG]${NC} $*" >&2
    fi
}

verbose() {
    if [[ "$VERBOSE" -eq 1 ]]; then
        echo -e "${CYAN}[VERBOSE]${NC} $*" >&2
    fi
}

# src/lib/scaffold.sh
# --- Core Logic ---

# Parses the scaffold.ini file
parse_ini_file() {
    local ini_file="$1"
    verbose "Parsing configuration from $ini_file"
    if ! [[ -f "$ini_file" ]]; then
        warn "scaffold.ini not found in template. Using command-line arguments or defaults."
        return
    fi

    # get_ini_value() {
    #     local key_to_find="$1"
    #     local found_value
    #     found_value=$(grep -E "^[[:space:]]*${key_to_find}[[:space:]]*=" "$ini_file" | head -n 1 | cut -d'=' -f2- | xargs)
    #     echo "$found_value"
    # }

    ini_load "$ini_file"

    if [[ -z "$ARTIFACT_ID" ]]; then ARTIFACT_ID=${ini["ID"]}; fi
    if [[ -z "$GROUP_ID" ]]; then GROUP_ID=${ini["GROUP_ID"]}; fi

    PRE_HOOK=${ini["PRE_HOOK"]:-}
    POST_HOOK=${ini["POST_HOOK"]:-}

    local desc_from_file; desc_from_file=${ini["DESCRIPTION"]:-}
    if [[ -n "$desc_from_file" ]]; then DESCRIPTION="$desc_from_file"; fi

    local author_from_file; author_from_file=${ini["AUTHOR"]:-"Unknown"}
    if [[ -n "$author_from_file" ]]; then AUTHOR="$author_from_file"; fi
}

# Replaces placeholders and creates Java package structure
replace_placeholders_and_structure() {
    local target_dir="$1"
    verbose "Starting placeholder replacement in $target_dir"

    local group_id_path="${GROUP_ID//./\/}"
    local artifact_id_path="${ARTIFACT_ID//-/}"
    local full_package_path="$group_id_path/$artifact_id_path"

    for root in "src/main/java" "src/test/java"; do
        local dest_package_dir="$target_dir/$root/$full_package_path"
        mkdir -p "$dest_package_dir"
        verbose "Created package structure: $dest_package_dir"
    done

    find "$target_dir" -depth -type f -name '*${*}*' | while read -r file; do
        local new_file_name; new_file_name=$(echo "$file" | sed "s|\${GROUP_ID}|$GROUP_ID|g; s|\${ID}|$ARTIFACT_ID|g")
        if [[ "$file" != "$new_file_name" ]]; then
            mv "$file" "$new_file_name"
            verbose "Renamed file: $file -> $new_file_name"
        fi
    done

    find "$target_dir" -type f -print0 | while IFS= read -r -d $'\0' file; do
        local temp_file; temp_file=$(mktemp)
        sed "s|\${GROUP_ID}|$GROUP_ID|g; s|\${ID}|$ARTIFACT_ID|g; s|\${DESCRIPTION}|$DESCRIPTION|g; s|\${AUTHOR}|$AUTHOR|g" "$file" > "$temp_file" && mv "$temp_file" "$file"
        debug "Processed content in file: $file"
    done

    log "Placeholder replacement and structuring complete."
}

execute_hook() {
    local hook_command="$1"
    local hook_name="$2"

    if [[ -z "$hook_command" ]]; then
        debug "No $hook_name hook script defined. Skipping."
        return
    fi
    hook_command="${hook_command#\"}"
    hook_command="${hook_command#\'}"

    hook_command="${hook_command%\"}"
    hook_command="${hook_command%\'}"

    log "Executing $hook_name hook..."
    verbose "Running command: $hook_command"

    (
        cd "$OUTPUT_DIR"
        if ! eval "$hook_command"; then
            error "$hook_name hook failed. Command: '$hook_command'"
            exit 1
        fi
    )
    log "$hook_name hook executed successfully."
}

# src/lib/utils.sh
# --- Utility Functions ---
check_dependencies() {
    local deps=("$@")
    local missing=()
    log "Checking for: ${deps[*]}"
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" >/dev/null 2>&1; then
            missing+=("$dep")
        fi
    done
    if [[ ${#missing[@]} -gt 0 ]]; then
        error "Missing required dependencies: ${missing[*]}"
        error "Please install them and try again."
        exit 1
    fi
}

check_directory() {
    local dir="$1"
    if [[ ! -d "$dir" ]]; then
        error "Directory not found: $dir"
        return 1
    fi
    if [[ ! -r "$dir" ]]; then
        error "Directory not readable: $dir"
        return 1
    fi
    return 0
}

print_dependencies() {
    echo "Required dependencies for $SCRIPT_NAME:"
    echo "  - rsync: For copying local templates."
    echo "  - git:   For cloning remote templates."
    echo ""
    echo "The script also uses common core utilities like: sed, grep, find, cut, xargs, mkdir, mv, rm."
}

prompt_for_input() {
    local prompt_message="$1"
    local -n var_to_set="$2"

    while [[ -z "${var_to_set}" ]]; do
        echo -e -n "${YELLOW}${prompt_message}:${NC} " >&2
        read -r var_to_set
        if [[ -z "${var_to_set}" ]]; then
            warn "This value cannot be empty."
        fi
    done
}

# src/lib/validate.sh
# --- Argument Validation ---
validate_args() {
    if [[ -n "$TEMPLATE_PATH" && -n "$GIT_REPO" ]]; then
        error "Options --path and --git are mutually exclusive."
        exit 1
    fi
    if [[ -z "$TEMPLATE_PATH" && -z "$GIT_REPO" ]]; then
        error "A template source is required. Use --path or --git."
        exit 1
    fi

    if [[ -n "$TEMPLATE_PATH" ]]; then
        check_directory "$TEMPLATE_PATH" || exit 1
    fi

    if [[ -e "$OUTPUT_DIR" && "$OUTPUT_DIR" != "." ]]; then
        if [[ "$FORCE" -eq "1" ]]; then
            warn "Output directory '$OUTPUT_DIR' already exists. Overwriting."
            rm -rf "$OUTPUT_DIR"
        else
            error "Output directory '$OUTPUT_DIR' already exists. Use --force to overwrite."
            exit 1
        fi
    fi
    mkdir -p "$OUTPUT_DIR"
    OUTPUT_DIR="$(cd "$OUTPUT_DIR" && pwd)"
}

# :command.command_functions

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        scaffold_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="root"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --deps)

        # :flag.case_no_arg
        args['--deps']=1
        shift
        ;;

      # :flag.case
      --debug | -d)

        # :flag.case_no_arg
        args['--debug']=1
        shift
        ;;

      # :flag.case
      --verbose | -V)

        # :flag.case_no_arg
        args['--verbose']=1
        shift
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      # :flag.case
      --path | -p)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--path']="$2"
          shift
          shift
        else
          printf "%s\n" "--path requires an argument: --path, -p PATH" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --git | -g)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--git']="$2"
          shift
          shift
        else
          printf "%s\n" "--git requires an argument: --git, -g GIT_REPO" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --gitsubdir)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--gitsubdir']="$2"
          shift
          shift
        else
          printf "%s\n" "--gitsubdir requires an argument: --gitsubdir GIT_SUB_DIRECTORY" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --group-id)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--group-id']="$2"
          shift
          shift
        else
          printf "%s\n" "--group-id requires an argument: --group-id GROUP_ID" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --artifact-id)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--artifact-id']="$2"
          shift
          shift
        else
          printf "%s\n" "--artifact-id requires an argument: --artifact-id ARTIFACT_ID" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --out | -o)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--out']="$2"
          shift
          shift
        else
          printf "%s\n" "--out requires an argument: --out, -o DIR" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['--out']:-} ]] || args['--out']="."

}

# :command.initialize
initialize() {
  declare -g version="1.2.0"
  set -e

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "root") root_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  initialize
  run "$@"
fi
